<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html lang="en">

<head>

<link rel="apple-touch-icon" href="http://introcs.cs.princeton.edu/apple-touch-icon.png"></link>
<link rel="shortcut icon"    href="http://introcs.cs.princeton.edu/favicon.ico"></link>

<link rel="stylesheet"       href="http://introcs.cs.princeton.edu/introcs.css" type="text/css" media="screen"></link>

<meta name="google-site-verification" content="nYspbl5bNBQrNZKguiAAFTMVM7sq2P1WQYc8Oi6Okl0" />
<meta name="msvalidate.01" content="D4B7F6DF793EFF34DE96F611C2A367A5" />
<!-- IE HACKS -->
<!--[if IE]>
<style type="text/css" media="screen">
 #menu ul li {float: left; width: 100%;}
</style>
<![endif]-->
<!--[if lt IE 7]>
<style type="text/css" media="screen">
body {
behavior: url(/csshover.htc);
} 
#menu ul li {float: left; width: 100%;}
#menu ul li a {height: 1%;} 

#menu a, #menu h2 {
font: bold 0.9em/1.5em arial, helvetica, sans-serif;
} 

</style>
<![endif]-->


<title>
Regular Expressions</title>
<script type='text/javascript' src='http://algs4.cs.princeton.edu/media/swfobject.js'></script>

<META HTTP-EQUIV="Content-Type" content="text/html; charset=iso-8859-1">
<META NAME="AUTHOR" CONTENT="Robert Sedgewick and Kevin Wayne">
<META NAME="KEYWORDS" CONTENT="Regular Expressions,Java,Programming,interdisciplinary,Computer science,cs,intro,introduction,sedgewick,wayne">
<META NAME="DESCRIPTION" CONTENT="This textbook provides an interdisciplinary approach to the CS 1 curriculum. We teach the classic elements of programming, using an "objects-in-the-middle" approach that emphasizes data abstraction. A key feature of the book is the manner in which we motivate each programming concept by examining its impact on specific applications, taken from science, engineering, and commerce.">
<META NAME="TITLE" CONTENT="Regular Expressions. Introduction to Programming in Java by Sedgewick and Wayne">
<META NAME="ROBOTS" CONTENT="INDEX,FOLLOW">
<META name="verify-v1" content="D4o9ikkHbNKapHncCP8ZmiD9Z2DBbrJyaSV0lyce+3w=">


</head>





<body>

<div id = "menu">
   <div align="center">
<a class = picture href = "/home">
<img src="../cover.png" width=190 border=0 alt = "Introduction to Programming in Java">
</a>
</div>






<ul>
  <li><a class = title href = "/java/home">Intro to Programming</a>
    <ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/10elements">1.&nbsp;&nbsp;Elements of Programming</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/11hello">1.1&nbsp;&nbsp;Your First Program</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/12types">1.2&nbsp;&nbsp;Built-in Types of Data</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/13flow">1.3&nbsp;&nbsp;Conditionals and Loops</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/14array">1.4&nbsp;&nbsp;Arrays</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/15inout">1.5&nbsp;&nbsp;Input and Output</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/16pagerank">1.6&nbsp;&nbsp;Case Study: PageRank</a>
        </ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/20functions">2.&nbsp;&nbsp;Functions</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/21function">2.1&nbsp;&nbsp;Static Methods</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/22library">2.2&nbsp;&nbsp;Libraries and Clients</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/23recursion">2.3&nbsp;&nbsp;Recursion</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/24percolation">2.4&nbsp;&nbsp;Case Study: Percolation</a>
        </ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/30oop">3.&nbsp;&nbsp;OOP</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/31datatype">3.1&nbsp;&nbsp;Data Types</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/32class">3.2&nbsp;&nbsp;Creating Data Types</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/33design">3.3&nbsp;&nbsp;Designing Data Types</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/34nbody">3.4&nbsp;&nbsp;Case Study: N-Body</a>
        </ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/40algorithms">4.&nbsp;&nbsp;Data Structures</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/41analysis">4.1&nbsp;&nbsp;Performance</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/42sort">4.2&nbsp;&nbsp;Sorting and Searching</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/43stack">4.3&nbsp;&nbsp;Stacks and Queues</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/44st">4.4&nbsp;&nbsp;Symbol Tables</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/45graph">4.5&nbsp;&nbsp;Case Study: Small World</a>
        </ul>
    </ul>
</ul>





<ul>
  <li><a class = title href = "/java/cs">Intro to CS</a>
    <ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/00prologue">0.&nbsp;&nbsp;Prologue</a>
        <ul>
        </ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/50machine">5.&nbsp;&nbsp;A Computing Machine</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/51data">5.1&nbsp;&nbsp;Data Representations</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/52toy">5.2&nbsp;&nbsp;TOY Machine</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/53isa">5.3&nbsp;&nbsp;TOY Instruction Set</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/54programming">5.4&nbsp;&nbsp;TOY Programming</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/55simulator">5.5&nbsp;&nbsp;TOY Simulator</a>
        </ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/60circuits">6.&nbsp;&nbsp;Building a Computer</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/61combinational">6.1&nbsp;&nbsp;Combinational Circuits</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/62sequential">6.2&nbsp;&nbsp;Sequential Circuits</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/63architecture">6.3&nbsp;&nbsp;Building a TOY</a>
        </ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/70theory">7.&nbsp;&nbsp;Theory of Computation</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/71language">7.1&nbsp;&nbsp;Formal Languages</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/72regular">7.2&nbsp;&nbsp;Regular Expressions</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/73dfa">7.3&nbsp;&nbsp;Finite State Automata</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/74turing">7.4&nbsp;&nbsp;Turing Machines</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/75universality">7.5&nbsp;&nbsp;Universality</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/76computability">7.6&nbsp;&nbsp;Computability</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/77intractability">7.7&nbsp;&nbsp;Intractability</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/78crypto">7.8&nbsp;&nbsp;Cryptography</a>
        </ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/80systems">8.&nbsp;&nbsp;Systems</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/81library">8.1&nbsp;&nbsp;Library Programming</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/82compiler">8.2&nbsp;&nbsp;Compilers</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/83os">8.3&nbsp;&nbsp;Operating Systems</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/84network">8.4&nbsp;&nbsp;Networking</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/85application">8.5&nbsp;&nbsp;Applications Systems</a>
        </ul>

      <li> <a href = "http://introcs.cs.princeton.edu/java/90scientific">9.&nbsp;&nbsp;Scientific Computation</a>
        <ul>
          <li> <a href = "http://introcs.cs.princeton.edu/java/91float">9.1&nbsp;&nbsp;Floating Point</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/92symbolic">9.2&nbsp;&nbsp;Symbolic Methods</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/93integration">9.3&nbsp;&nbsp;Numerical Integration</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/94diffeq">9.4&nbsp;&nbsp;Differential Equations</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/95linear">9.5&nbsp;&nbsp;Linear Algebra</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/96optimization">9.6&nbsp;&nbsp;Optimization</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/97data">9.7&nbsp;&nbsp;Data Analysis</a>
          <li> <a href = "http://introcs.cs.princeton.edu/java/98simulation">9.8&nbsp;&nbsp;Simulation</a>
        </ul>
    </ul>
</ul>







<ul>

<li><a class = title> Related Booksites</a>
<table width = 100% border = 0 cellspacing = 0 cellpadding = 0>
<tr>
<td align = center>
<a class = booksite href = "http://introcs.cs.princeton.edu/python">
   <img src = "http://introcs.cs.princeton.edu/java/cover-python.png"
        width = 73 height = 91 border=0
        alt = "Introduction to Programming in Python
               by Robert Sedgewick, Kevin Wayne, and Robert Dondero">
</a>
<td align = center>
<a class = booksite href = "http://algs4.cs.princeton.edu">
   <img src = "http://algs4.cs.princeton.edu/cover.png"
        width = 73 height = 91 border=0
        alt = "Algorihtms, 4th Edition by Robert Sedgewick and Kevin Wayne">
</a>
</tr>
</table>


  <li><a class = title href = "/home">Web Resources</a>
    <ul>

      <li> <a href = "/java/faq">FAQ</a>
      <li> <a href = "/java/data">Data</a>
      <li> <a href = "/java/code">Code</a>
      <li> <a href = "/java/errata">Errata</a>
      <li> <a href = "/java/11appendix">Appendices</a>
        <ul>
          <li> <a href = "/java/11precedence">A. &nbsp; Operator Precedence</a>
          <li> <a href = "/java/11style">B. &nbsp; Writing Clear Code</a>
          <li> <a href = "/java/11gaussian">C. &nbsp; Gaussian Distribution</a>
          <li> <a href = "/java/11cheatsheet">D. &nbsp; Java Cheatsheet</a>
          <li> <a href = "/java/11matlab">E. &nbsp; Matlab</a>
        </ul>
      <li> <a href="/java/lectures">Lecture Slides</a>
      <li> <a href="/java/assignments">Programming Assignments</a>
   </ul>


</ul>

<p><br>


<script>
  (function() {
    var cx = '005649317310637734940:_d158dlngnk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:searchbox-only></gcse:searchbox-only>

<p><br>
</div>

<div id = "content">
   <H1>7.2 &nbsp; Regular Expressions</H1>
<p><br>


<font color = "red">
This section under major construction.
</font>

<p>
Manipulating text (email, web pages, word processing documents, DNA sequences, 
Java programs) is one of the most basic and important computing tasks.

<p><b>Pattern matching.</b>
One of the most important text processing problem is pattern matching.
The simplest version of the problem is to search for one occurrence
(or all occurrences) of some specific string in a large document.
For example, we might want to search for the word "needle" in 
a large word processing document, or we might want to search for
all occurrences of the string "acgagggtttaccgaagaat" in the human genome.
The <a href = "http://www.ncbi.nlm.nih.gov/BLAST/">BLAST</a> database
from the NCBI is a quintessential searching tool for computational
molecular biologists.
Sometimes we are interested in searching for more complex patterns.
When validating a web form, we might like to check whether or not the
email address is syntactically valid, e.g., <tt>wayne@cs.princeton.edu</tt>
looks like an email address, but <tt>gf!@#$bB</tt> does not. A simple
test for a valid email address might be: a sequence of one or more
lowercase letters, followed by the <tt>@</tt> symbol,
followed by another sequence of lowercase letters followed by a <tt>.</tt>
followed by another sequence of lowercase letters followed by <tt>edu</tt>
or <tt>net</tt>. In this section, we will explore effective ways for
specifying such patterns and solving the corresponding pattern matching problem.

<p><b>Other applications.</b>
Scan for virus signatures, process natural language, search for information using Google,
access information in digital libraries, access information in databases
(e.g., Oracle Database 10g, MySQL 3.23)
retrieve information from Lexis/Nexis, search-and-replace in a word processors,
filter text (spam, NetNanny, Carnivore, malware), validate data-entry fields
(dates, email, URL, credit card).
Another class of important applications is parsing data files in the natural
and social sciences. Some computational physics experiments generate terrabytes of
output. It is hopeless to search for useful information without automated methods.
Read in data stored in TOY input file format,
compile a Java program, crawl and index the Web,
automatically create Java documentation from Javadoc comments, ...


<p><b>Regular expressions.</b>
A <em>regular expression</em> is notation for specifying a set of strings,
e.g., the set of all valid email addresses or the set of all binary strings with
an even number of 1s. Since the set might contain infinitely many members,
we can't simply enumerate them. There are five basic operations for creating
regular expressions, and the table below illustrates them by example.

<p>
<blockquote>
<table cellspacing="1" cellpadding="5" border="0">
<tr>
<th>Operation</th>
<th>Regular Expression</th>
<th>Yes</th>
<th>No</th>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Concatenation</td>
<td><tt>aabaab</tt></td>
<td><tt>aabaab</tt></td>
<td>every other string</td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Logical OR<br>(Alternation)</td>
<td><tt>aa | baab</tt></td>
<td><tt>aa<br>baab</tt></td>
<td>every other string</td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Replication<br>(Kleene closure)</td>
<td><tt>ab*a</tt></td>
<td><tt>aa<br>aba<br>abba</tt></td>
<td>&epsilon;<br><tt>ab<br>ababa</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Grouping</td>
<td><tt>a(a|b)aab</tt></td>
<td><tt>aaaab<br>abaab</tt></td>
<td>every other string</td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Wildcard</td>
<td><tt>a..a</tt></td>
<td><tt>abba<br>abaa</tt></td>
<td><tt>aa</tt><br><tt>aaaaa</tt></td>
</tr>

</table>
</blockquote>

<ul>

<p><li>
<em>Concatenation</em>: the simplest type of regular expression is formed
by concatenating a bunch of symbols together, one after the other,
like <tt>aabaab</tt>.
This regular expression matches only the single string <tt>aabaab</tt>.
We can perform simple spell checking by using the concatenation
operation. For example, we could form the regular expression <tt>niether</tt>
and then for each word in a dictionary check whether that word matches
the regular expression. Presumably no word in the dictionary would match,
and we would conclude that <tt>niether</tt> is misspelled.

<p><li>
<em>Logical OR</em>: the logical OR operator enables us to choose
from one of several possibilities. For example, the regular expression
<tt>aa | baab</tt> matches exactly two strings <tt>aa</tt> and <tt>baab</tt>.
Many spam filters (e.g., SpamAssassin) work by searching for a long list of
common spamming terms. They might form a regular expression such as
<tt>AMAZING | GUARANTEE | Viagra</tt>.
The logical OR operator enables us to specify  many strings
with a single regular expression.
For example, if our phone number
is 734-8527, we might like to know whether it spells out any word
on the phonepad (2 = abc, 3 = def, 4 = ghi, 5 = jkl, 6 = mno, 7 = prs, 
8 = tuv, 9 = wxy). The following regular expression specifies all
of the 3^7 possible combinations
<tt>(p|r|s)(d|e|f)(g|h|i)(t|u|v)(j|k|l)(a|b|c)(p|r|s)</tt>.
It turns out that the only English word that matches is the
word <tt>regular</tt>. (Replace this example with decoding an
IM message that uses the "phone code.")


<p><li>
<em>Replication</em>: the replication operator enables us to specify 
infinitely many possibilities. For example, the regular expression
<tt>ab*a</tt> matches <tt>aa</tt>, <tt>aba</tt>, <tt>abba</tt>, <tt>abbba</tt>,
an so forth. Note that 0 replications of <tt>b</tt> are permitted.

<p><li>
<em>Grouping</em>: the grouping operator enables us to specify 
precedence to the various operators. The replication operator has the highest
precedence, then concatenation, then logical OR. If we want to specify 
the set of strings <tt>a</tt>, <tt>aba</tt>, <tt>ababa</tt>, <tt>abababa</tt>,
and so forth, we must write <tt>(ab)*a</tt> to indicate that the
<tt>ab</tt> pattern must be replicated together.

<p><li>
<em>Wildcard</em>: the wildcard symbol matches exactly one
occurrence of any single character.

</ul>

<p><em>Building blocks of Java vs. regular expressions.</em>
These building blocks parallel the way Java programs are written.
Straight-line programs are sequence of instructions executed one after 
the other. The concatenation operation is formed by combining
a sequence of regular expressions, one after the other.
Branch statements (if-else) enable us to execute one of several possible
statements. The logical OR operation matches one of two possible
expressions. Combining several branch statements or OR operations
enable us to deal with exponentially many possibilities.
While loops take us into the infinite and allow us to repeat things
any number of times.
The replication operator plays a similar role.
Finally, in Java we group statements together in blocks by surrounding
them with curly braces.
With regular expressions, we use parentheses.
There is one crucial difference between Java programs and regular 
expressions. In Java, we can declare variables and use them
to store intermediate values in a computation, whereas with
regular expressions there is no such mechanism to remember state.


<p><b>Regular expression examples.</b>
The operators described are the building blocks of regular expressions.
By combining them in clever ways, we can express very complicated patterns.
One particularly useful regular expression is <tt>(a|b)*</tt>.
This means take either the symbol <tt>a</tt> or the symbol <tt>b</tt>,
zero or more times. This has the effect of matching all possible
strings of a's and b's. If we want to match all strings that contain
<tt>aacgaagggact</tt> as a substring, we can use the regular expression
<tt>(a|c|g|t)*aacgaagggact(a|c|g|t)*</tt>. The following table illustrates
some additional combinations.

<p><br>
<blockquote>
<table cellspacing="1" cellpadding="5" border="0">
<tr>
<th>Regular Expression</th>
<th>Yes</th>
<th>No</th>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td><tt>a* | (a*ba*ba*ba*)*</tt><br>multiple of 3 b's</td>
<td>&epsilon;<br><tt>bbb<br>aaa<br>abbbaaa<br>bbbaababbaa</tt></td>
<td><tt>b<br>bb<br>abbaaaa<br>baabbbaa</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td><tt>a | a(a|b)*a</tt><br>begins and ends with a</td>
<td><tt>a<br>aba<br>aa<br>abbaabba</tt></td>
<td>&epsilon;<br><tt>ab<br>ba</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td><tt>(a|b)*abba(a|b)*</tt><br>contains the substring abba</td>
<td><tt>abba<br>bbabbabb<br>abbaabba</tt></td>
<td>&epsilon;<br><tt>abb<br>bbaaba</tt></td>
</tr>


</table>
</blockquote>

<p><br>

<p><b>FMR-1 triplet repeat region.</b>
"The human FMR-1 gene sequence contains a triplet repeat region
in which the sequence CGG or AGG is repeated a number of times. The number
of triplets is highly variable between individuals, and increased
copy number is associated with fragile X syndrome, a genetic disease
that causes mental retardation and other symptoms in one out of
2000 children." (Reference: Biological Sequence Analysis by
Durbin et al). The pattern is bracket by GCG and CTG,
so we get the regular expression GCG (CGG | AGG)* CTG.


<p><b>Using regular expressions.</b>
Regular expressions are a standard programmer's tool. They are built
into most modern languages including Java, Perl, and Python.
The Unix program <tt>
grep</tt> and the Windows program <tt>findstr</tt>
are indispensable command line tools when searching for data (in programs,
email, or wherever).
History of <a href = "http://www.columbia.edu/~rh120/ch106.x09">grep</a>
and other Unix tools. Developed by Ken Thompson in 1973 to aid McIlroy
in reading text aloud through a voice synthesizer.
Program <a href = "Validate.java.html">Validate.java</a> demonstrates
how to use regular expressions in Java using the string library method
<tt>matches</tt>. The user enters the text string and the pattern
on the command line, and the program prints out <tt>true</tt> or <tt>false</tt>,
depending on whether or not the text matches the pattern.
<blockquote>
<table>
<TR><TD><pre>
public class Validate { 
    public static void main(String[] args) { 
        String pattern = args[0];
        String text    = args[1];
        System.out.println(text.matches(pattern));
    }
}
</pre></td></tr>
</table>
</blockquote>
<p>

As a simple example, we might check to see if the text has
a multiple of 3 b's.
<blockquote>
<table>
<TR><TD><pre>
% java Validate "a* | (a*ba*ba*ba*)*" abbbaaa
true

% java Validate "a* | (a*ba*ba*ba*)*" abbaaa
false
</pre></td></tr>
</table>
</blockquote>
<p>
We note that we must use quotation marks to delimit the pattern,
since otherwise the operating system would interpret the | and * symbols
before passing along the string to the Java program.

<p>
The first four basic operations above (concatenation, logical or,
replication, grouping) are the theoretical minimum needed to describe
regular expressions.
Most programming environments support additional operations for convenience
(including the wildcard operation), and Java is no exception.
The table below includes some of the highlights.

<p><br>
<blockquote>
<table cellspacing="1" cellpadding="5" border="0">
<tr>
<th>Operation</th>
<th>Java Regular Expression</th>
<th>Yes</th>
<th>No</th>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>One or more</td>
<td><tt>a(bc)+de</tt></td>
<td><tt>abcde</tt><br><tt>abcbcde</tt></td>
<td><tt>ade</tt><br><tt>abc</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Once or not at all</td>
<td><tt>a(bc)?de</tt></td>
<td><tt>ade<br>abcde</tt></td>
<td><tt>abc<br>abcbcde</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Character classes</td>
<td><tt>[a-m]*</tt></td>
<td><tt>blackmail</tt><br><tt>imbecile</tt></td>
<td><tt>above<br>below</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Negation of character classes</td>
<td><tt>[^aeiou]</tt></td>
<td><tt>b<br>c</tt></td>
<td><tt>a<br>e</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Exactly N times</td>
<td><tt>[^aeiou]{6}</tt></td>
<td><tt>rhythm</tt><br><tt>syzygy</tt></td>
<td><tt>rhythms</tt><br><tt>allowed</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Between M and N times</td>
<td><tt>[a-z]{4,6}</tt></td>
<td><tt>spider<br>tiger</tt></td>
<td><tt>jellyfish<br>cow</tt></td>
</tr>

<tr align = center bgcolor = "#ebebeb">
<td>Whitespace characters</td>
<td><tt>[a-z\s]*hello</tt></td>
<td><tt>hello</tt><br><tt>say hello</tt></td>
<td><tt>Othello<br>2hello</tt></td>
</tr>

<!--
<tr align = center bgcolor = "#ebebeb">
<td>Back reference</td>
<td><tt>(.*)\1</tt></td>
<td><tt>beriberi<br>couscous</tt></td>
<td><tt>java<br>regular</tt></td>
</tr>
-->

</table>
</blockquote>

<p><br>

Program <a href = "Grep.java.html">Grep.java</a> reads
in a regular expression from the command line and processes standard
input one line at a time, printing out any lines <em>contain</em>
 exact matches as substrings.
<p><br>
Here is Oracle's guide to 
<a href = "http://docs.oracle.com/javase/tutorial/essential/regex/">using regular expressions</a>.
It includes
<a href = "http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">many more operations</a>
that we will not explore.
Also see the <tt>String</tt> methods <tt>matches()</tt>, <tt>split()</tt>, and
<tt>replaceAll()</tt>. These are shorthands for 
using the <tt>Pattern</tt> and <tt>Matcher</tt> classes.
Here's some 
<a href = "http://javaalmanac.com/cgi-bin/search/find.pl?words=regex">common
regular expression patterns</a>.


<p><b>Regular expression applications.</b>
Email addresses, Java identifiers, integers, decimal, ....
<p>

Our email address example has been greatly simplified for convenience.
Here's a <a href = "http://regexlib.com/">library of useful regular expressions</a>
that offers industrial grade patterns for
email addresses, URLs, numbers, dates, and times.
Try this <a href = "http://www.weitz.de/regex-coach/">regular expression tool</a>.



<p><b>Harvester.</b>
The method <tt>String.matches</tt> is useful when we want to search
for some pattern in a string. To do repeated searches in Java, we
specify the pattern using a regular expression, preprocess it using
<tt>Pattern.compile</tt> and <tt>Pattern.matcher</tt>, and
check for matches using <tt>Matcher.find</tt> and <tt>Matcher.group</tt>.
Program <a href = "Harvester.java.html">Harvester</a> illustrates
this process. It prints out all of the email addresses on a given web page.
Create a regular expression that matches email addresses that start
with one or more letters, followed by a @, followed by a sequence of
letters, then a ., then letters, then a ., and so forth, and finally
ending with com, edu, or gov. Note: to match a <tt>.</tt>, we use <tt>//.</tt>
in the Java regular expression to escape the <tt>.</tt>.
The variable <tt>input</tt> is a long string.
<blockquote>
<table>
<TR><TD><pre>
Pattern pattern = Pattern.compile(regexp);
Matcher matcher = pattern.matcher(input);
while (matcher.find()) {
   System.out.println(matcher.group());
}
</pre></td></tr>
</table>
</blockquote>


<p>
<b>Ad blocking.</b>
<a href = "http://adblock.mozdev.org/">Adblock</a> uses regular
expressions to block banner adds under the Mozilla and Firebird
browsers.



<p>
<b>Parsing text files.</b>
A more advanced example where we want to extract specific pieces of the
matching input. This program typifies the process of parsing 
scientific input data.
The TOY program input file consists of a sequence of lines.
If a line begins with two hex digits <em>xy</em>, followed by a
colon, followed by a space, followed by four hex digits <em>abcd</em>,
then we load instruction <em>abcd</em> into memory location
<em>xy</em>. Otherwise, we ignore the line. 
We use a Java regular expression to parse each line.
<blockquote>
<table>
<TR><TD><pre>
String filename = args[0];
In in = new In(filename);
String regexp = "([0-9A-Fa-f]{2}):[ \t]*([0-9A-Fa-f]{4}).*";
Pattern pattern = Pattern.compile(regexp);
String line;
while ((line = in.readLine()) != null) {
   Matcher matcher = pattern.matcher(line);
   if (matcher.find()) {
      int addr = fromHex(matcher.group(1));
      int inst = fromHex(matcher.group(2));
      mem[addr] = inst;
   }
}
</pre></td></tr>
</table>
</blockquote>
<p>
The method call <tt>matcher.group(1)</tt> returns the substring that matches the portion
of the regular expression delimited by the first set of parentheses (the
two hex digits).
The method call <tt>matcher.group(2)</tt> returns the substring that matches the
portion of the regular expression delimited by the second set
of parentheses (the 4 hex digits). The colon, whitespace, and any comments
are ignored.

<p><b>PROSITE.</b>
PROSITE is the
"first and most famous" database of protein families and domains.
Its main use it to determine the function of uncharacterized proteins translated 
from genomic sequences. 
Biologists use
<a href = "http://us.expasy.org/tools/scanprosite/scanprosite-doc.html">PROSITE</a>
pattern syntax rules to  search for patterns in biological data.
Here is the raw data for 
<a href = "http://us.expasy.org/cgi-bin/get-prosite-raw.pl?PS00562">CBD FUNGAL</a>
(accession code PS00562). Each line contains various information. Perhaps
the most interesting line is the one that begins with PA - it contains
the pattern that describes the protein motif.
Such patterns are useful because they often correspond to 
functional or structural features.
<blockquote>
<table>
<TR><TD><pre>
PA   C-G-G-x(4,7)-G-x(3)-C-x(5)-C-x(3,5)-[NHG]-x-[FYWM]-x(2)-Q-C.
</pre></td></tr>
</table>
</blockquote>
<p>
Each uppercase letter corresponds to one amino acid residue.
The alphabet consists of uppercase letters corresponding to the 
2x amino acids.
The <tt>-</tt> character means concatenation.
For example, the pattern above begins with CGG (Cys-Gly-Gly).
The notation <tt>x</tt> plays the role of a wildcard - it matches 
any amino acid. This corresponds to <tt>.</tt> in our notation.
Parentheses are used to specify repeats:
<tt>x(2)</tt> means
exactly two amino acids, and <tt>x(4,7)</tt> means between 4 and 7 amino
acids. This corresponds to <tt>.{2}</tt> and <tt>.{4,7}</tt> in Java
notation.
Curly braces are used to specify forbidden residues:
{CG} means any residue other than C or G.
The asterisk has its usual meaning.


<p>
Could also mention the <tt>String</tt> library method <tt>split()</tt> that we used in
the Kevin Bacon program to parse /-delimited text files. The argument
can be a general regular expression, instead of just "/" character.



<p><b>Wildcards.</b>
Specialization of regular expressions. Use symbol <tt>*</tt> to mean <tt>.*</tt>,
i.e., match any number of characters. No parenthesis or logical OR operation.
Common with operating systems, e.g., to list all files ending in <tt>.txt</tt>.
<blockquote>
<table>
<TR><TD><pre>
ls *.txt       // Unix, Linux, OS X
dir *.txt      // Windows
</pre></td></tr>
</table>
</blockquote>
<p>
Also built in to search engines like Google.
Find all web pages with the phrase
<a href = "http://www.google.com/search?hl=en&lr=&ie=UTF-8&oe=utf-8&q=%22premature+*+is+the+root+of+all+evil%22+-optimization+-optimisation&btnG=Google+Search">
premature * is the root of all evil</a>.

<p><b>Web crawler.</b>
Google indexes the web by starting with a web page and exploring
all web pages that are directly linked from the first page.
Program <a href = "LinkFinder.java.html">LinkFinder.java</a>
takes the name of a web page as a command line input, and prints
out all web pages listed in the original web page. Use the following
approximate rule: starts with <tt>http://</tt> and is followed by
any number of non-whitespace characters except <tt>"</tt>.
This program could be used to check a webpage for broken links.

<p>
Program <a href = "WebCrawler.java.html">WebCrawler.java</a>
expands on <a href = "LinkFinder.java.html">LinkFinder.java</a>
by recursively finding the links on all of the pages that the
original page points to, and so on. It maintains a queue of web
pages that still need to be explored. As a result, the web
pages are examined in breadth first order, starting from the initial
seed page. To avoid visiting a web page more than once, we 
maintain a symbol table of previously visited pages.
It is somewhat restricted since it only follows absolute
web links of a special form, but it's a proof-of-concept program.
Also, you get error messages for all of the URLs that are malformed
on unreachable.



<H4>Q + A</H4>
<p><b>Q.</b>
I'm confused why does (a | b)* match all strings of a's and b's,
instead of only string with all a's or string with all b's?
<p><b>A.</b>
The * operator replicates the regular expression (and not a 
fixed string that matches the regular expression). So the above
is equivalent to &epsilon; | (a|b) | (a|b)(a|b) | (a|b)(a|b)(a|b) | ....

<p><b>Q.</b>
History?
<p><b>A.</b>
In the 1940s, Warren McCulloch and Walter Pitts modeled neurons as finite automata
to describe the nervous system.
In 1956, Steve Kleene invented a mathematical abstraction called
<em>regular sets</em> to describe these models.
<em>Representation of events in nerve nets and finite automata.</em>
in Automata Studies, 3-42, Princeton University Press, Princeton, New Jersey 1956.

<!--
<p><b>Q.</b>
Is there an industrial strength way to get all of the hyperlinks
on a web page?
<p><b>A.</b>
Yes, but it's somewhat complicated. Use Java's <tt>HTMLEditorKit</tt> library.
-->

<H4>Exercises</H4>
<ol>

<li>Write a regular expression for each of the following sets 
of binary strings. Use only the basic operations.
<ol>
<li>0 or 11 or 101
<li>only 0s
</ol>
<p>
<em>Answers</em>: 0 | 11 | 101, 0*

<li>Write a regular expression for each of the following sets 
of binary strings. Use only the basic operations.
<ol>
<li>all binary strings
<li>all binary strings except empty string
<li>begins with 1, ends with 1
<li>ends with 00
<li>contains at least three 1s
</ol>
<p>
<em>Answers</em>: (0|1)*, (0|1)(0|1)*, 1 | 1(0|1)*1, (0|1)*00,
(0|1)*1(0|1)*1(0|1)*1(0|1)* or 0*10*10*1(0|1)*.


<li>Write a regular expression to describe inputs over the alphabet
{a, b, c} that are in sorted order.
<em>Answer</em>: a*b*c*.


<li>Write a regular expression for each of the following sets 
of binary strings. Use only the basic operations.
<ol>
<li>contains at least three consecutive 1s
<li>contains the substring 110
<li>contains the substring 1101100
<li>doesn't contain the substring 110
</ol>

<p>
<em>Answers</em>: (0|1)*111(0|1)*, (0|1)*110(0|1)*,
(0|1)*1101100(0|1)*, (0|10)*1*.
The last one is by far the trickiest.

<li>Write a regular expression for binary strings
with at least two 0s but not consecutive 0s.


<li>Write a regular expression for each of the following sets 
of binary strings. Use only the basic operations.
<ol>
<li>has at least 3 characters, and the third character is 0
<li>number of 0s is a multiple of 3
<li>starts and ends with the same character
<li>odd length
<li>starts with 0 and has odd length, or starts with 1
and has even length
<li>length is at least 1 and at most 3
</ol>
<p>
<em>Answers</em>:
(0|1)(0|1)0(0|1)*, &nbsp; 
1* | (1*01*01*01*)*, &nbsp;
1(0|1)*1 | 0(0|1)*0 | 0 | 1, &nbsp;
(0|1)((0|1)(0|1))*, &nbsp;
0((0|1)(0|1))* | 1(0|1)((0|1)(0|1))*, &nbsp;
(0|1) | (0|1)(0|1) | (0|1)(0|1)(0|1).


<li>
For each of the following, indicate how many bit strings of
length exactly 1000 are matched by the regular expression:
<tt>0(0 | 1)*1</tt>, <tt>0*101*</tt>, <tt>(1 | 01)*</tt>.

<li>
Write a regular expression that matches all strings over the
alphabet {a, b, c} that contain:
<ol>
<li>starts and ends with a
<li>at most one a
<li>at least two a's
<li>an even number of a's
<li>number of a's plus number of b's is even
</ol>


<li>Find long words whose letters are in alphabetical 
order, e.g., <tt>almost</tt> and <tt>beefily</tt>.
<em>Answer</em>: use the regular expression
'^a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*$'.

<li>Write a Java regular expression to match phone numbers,
with or without area codes. The area codes should be of the 
form (609) 555-1234 or 555-1234.

<li>
Find all English words that end with <tt>nym</tt>.

<li>
Final all English words that contain the trigraph <tt>bze</tt>.
<em>Answer</em>: subzero.

<li>
Find all English words that start with g, contain the trigraph
<tt>pev</tt> and end with e.
<em>Answer</em>: grapevine.

<li>
Find all English words that contain the trigraph <tt>spb</tt>
and have at least two r's.

<li>
Find the longest English word that can be written with the top row 
of a standard keyboard.
<em>Answer</em>: proprietorier.


<li>
Find all words that contain the four letters a, s, d, and f,
not necessarily in that order.
<em>Solution</em>:
<tt> cat words.txt | grep a | grep s | grep d | grep f</tt>.

<li>
Given a string of A, C, T, and G, and X, find
a string where X matches any single character, e.g.,
CATGG is contained in ACTGGGXXAXGGTTT.


<li>Write a Java regular expression, for use with
 <a href = "Validate.java.html">Validate.java</a>, that validates Social Security
numbers of the form 123-45-6789.
<em>Hint:</em> use <tt>\d</tt> to represent any digit.
<em>Answer:</em> <tt>[0-9]{3}-[0-9]{2}-[0-9]{4}</tt>.

<li>Modify the previous exercise to make the <tt>-</tt> optional,
so that 123456789 is considered a legal input.

<li>Write a Java regular expression to match all strings that contain
exactly five vowels and the vowels are in alphabetical order.
<em>Answer:</em> <tt>[^aeiou]*a[^aeiou]*e[^aeiou]*i[^aeiou]*o[^aeiou]*u[^aeiou]*</tt>

<li>Write a Java regular expression to match valid Windows XP file names.
Such a file name consists of any sequence of characters other
than
<blockquote>
<table>
<TR><TD><pre>
/ \ : * ? " < > |
</pre></td></tr>
</table>
</blockquote>
<p>
Additionally, it cannot begin with a space or period.

<li>Write a Java regular expression to match valid OS X file names.
Such a file name consists of any sequence of characters other than
a colon.
Additionally, it cannot begin with a period.

<li>
Given a string <tt>s</tt> that represents the name of an IP 
address in <em>dotted quad</em> notation, break it up into 
its constituent pieces, e.g., 255.125.33.222.
Make sure that the four fields are numeric.

<li>Write a Java regular expression to describe all dates of
the form <em>Month DD, YYYY</em> where <em>Month</em> consists
of any string of upper or lower case letters, the date is 1 or 2
digits, and the year is exactly 4 digits. The comma and spaces
are required.

<li>Write a Java regular expression to describe valid IP addresses
of the form a.b.c.d where each letter can represent 1, 2, or 3
digits, and the periods are required. Yes: 196.26.155.241.


<li>Write a Java regular expression to match license plates
that start with 4 digits and end with two uppercase letters.


<li>Write a regular expression to extract the coding sequence
from a DNA string. It starts with the ATG codon and 
ends with a stop codon (TAA, TAG, or TGA).
<a href = "http://bioportal.weizmann.ac.il/course/prog/regexps/5.html">reference</a>

<li> Write a regular expression to check for the sequence
rGATCy: that is, does it start with A or G, then GATC, and then
T or C.

<li> Write a regular expression to check whether a sequence contains
two or more repeats of the the GATA tetranucleotide.


<li>Modify <a href = "Validate.java.html">Validate.java</a>
to make the searches case insensitive.
<em>Hint:</em> use the <tt>(?i)</tt> embedded flag.

<li>
Write a Java regular expression to match various spellings
of Libyan dictator Moammar Gadhafi's last name using
the folling template: (i) starts with K, G, Q, (ii) optionally
followed by H, (iii) followed by AD, (iv) optionally followed
by D, (v) optionally followed by H, (vi) optionally followed
by AF, (vii) optionally followed by F, (vii) ends with I.

<li>
Write a Java program that reads in an expression
like <tt>(K|G|Q)[H]AD[D][H]AF[F]I</tt> and prints out all
matching strings. Here the notation <tt>[x]</tt> means
0 or 1 copy of the letter <tt>x</tt>.

<li>Why doesn't <tt>s.replaceAll("A", "B");</tt> replace all
occurrences of the letter A with B in the string s?
<p>
<em>Answer</em>: Use <tt>s = s.replaceAll("A", "B");</tt> instead
The method <tt>replaceAll</tt> returns the resulting string, but
does not change <tt>s</tt> itself.
Strings are immutable.


<li>
Write a program <a href = "Clean.java.html">Clean.java</a>
that reads in text from standard input and
prints it back out, removing any trailing whitespace on a line
and replacing all tabs with 4 spaces.
<p>
<em>Hint:</em> use <tt>replaceAll()</tt> and the regular expression
<tt>\s</tt> for whitespace.

<li>Write a regular expression to match all of the text
between the text <tt>a href ="</tt> and the next <tt>"</tt>.
<em>Answer</em>: <tt>href=\"(.*?)\"</tt>. The
<tt>?</tt> makes the <tt>.*</tt> reluctant instead of greedy.
In Java, use <tt>Pattern.compile("href=\\\"(.*?)\\\"", Pattern.CASE_INSENSITIVE)</tt>
to escape the backslash characters.

<li>Use regular expressions to extract all of the text 
between the tags
<tt>&lt;title&gt;</tt> and <tt>&lt;\title&gt;</tt>.
The <tt>(?i)</tt> is another way to make the match case insensitive.
The <tt>$2</tt> refers to the second captured subsequence, i.e.,
the stuff between the <tt>title</tt> tags.

<blockquote>
<table>
<TR><TD><pre>
String pattern = "(?i)(&lt;title.*?&gt;)(.+?)(&lt;/title&gt;)"; 
String updated =  s.replaceAll(pattern, "$2");
</pre></td></tr>
</table>
</blockquote>



<li>Write a regular expression to match all of the text
between &lt;TD ...&gt; and &lt;/TD&gt; tags.
<em>Answer</em>: <tt> &lt;TD[^&gt;]*&gt;([^&lt;]*)&lt;/TD&gt; </tt>



</ol>





<H4>Creative Exercises</H4>
<ol>

<li><b>Text to speech synthesis.</b>
Original motivation for grep. "For example, how do you cope with 
the digraph ui, which is pronounced many different ways: 
fruit, guile, guilty, anguish, intuit, beguine?"


<li><b>Challenging regular expressions.</b>
Write a regular expression for each of the following sets 
of binary strings. Use only the basic operations.
<ol>
<li>any string except 11 or 111
<li>every odd symbol is a 1
<li>contains at least two 0s and at most one 1
<li>no consecutive 1s
</ol>

<li><b>Binary Divisibility.</b>
Write a regular expression for each of the following sets 
of binary strings. Use only the basic operations.
<ol>
<li>bit string interpreted as binary number is divisible by 3
<li>bit string interpreted as binary number is divisible by 123
</ol>

<li><b>Boston accent.</b>
Write a program to replace all of the r's with h's to translate
a sentence like "Park the car in Harvard yard" into the Bostonian
version "Pahk the cah in Hahvahd yahd".

<li><b>File extension.</b>
Write a program that takes the name of a file as a command line argument
and prints out its file type extension. The <em>extension</em>
is the sequence of characters following the last <tt>.</tt>.
For example the file <tt>sun.gif</tt> has the extension <tt>gif</tt>.
Hint: use <tt>split("\\.")</tt>; recall that <tt>.</tt> is 
a regular expression meta-character, so you need to escape it.

<li><b>Reverse subdomains.</b>
For web log analysis, it is convenient to organize web traffic
based on subdomains like <tt>wayne.faculty.cs.princeton.edu</tt>.
Write a program to read in a domain name and print it out
in reverse order like
<tt>edu.princeton.cs.faculty.wayne</tt>.

<li><b>Bank robbery.</b>
You just witnessed a bank robbery and got a partial license plate
of the getaway vehicle. It started with <tt>ZD</tt>, had
a <tt>3</tt> somewhere in the middle and ended with <tt>V</tt>.
Help the police officer write regular expression for this plate.

<li><b>Regular expression for permutations.</b>
Find the shortest regular expression (using only the basic operations)
you can for the set of all permutations on N elements for N = 5 or 10.
For example if N = 3, then the language is abc, acb, bac,
bca, cab, cba.
<em>Answer</em>: difficult. Solution has length exponential
in N.

<li><b>Parsing quoted strings.</b>
Read in a text file and print out all quote strings.
Use a regular expression like <tt>"[^"]*"</tt>, but need
to worry about escaping the quotation marks.

<li><b>Parsing HTML.</b>
A &gt;, optionally followed by whitespace, followed by <tt>a</tt>,
followed by whitespace, followed by <tt>href</tt>, optionally
followed by whitespace, followed by <tt>=</tt>, optionally 
followed by whitespace, followed by <tt>"http://</tt>,
followed by characters until <tt>"</tt>, optionally followed by
whitespace, then a <tt>&lt;</tt>.

<blockquote>
<table>
<TR><TD><pre>
< \s* a \s+ href \s* = \s* \\"http://[^\\"]* \\" \s* >
</pre></td></tr>
</table>
</blockquote>


<li><b>Subsequence.</b>
Given a string s, determine whether it is a subsequence of another
string t. For example, abc is a subsequence of achfdbaabgabcaabg.
Use a regular expression. Now repeat the process without using
regular expressions.
Answer: (a) a.*b.*c.*, (b) use a greedy algorithm.


<li><b>Huntington's disease diagnostic.</b>
The gene that causes Huntington's disease is located on chromosome 4,
and has a variable number of repeats of the CAG trinucleotide repeat.
Write a program to determine the number
of repeats and print <tt>will not develop HD</tt> If the number of repeats
is less than 26, <tt>offspring at risk</tt> if the number is 37-35,
<tt>at risk</tt> if the number is between 36 and 39, and <tt>will develop HD</tt>
if the number is greater than or equal to 40.
This is how Huntington's disease is identified in genetic testing.

<li><b>Gene finder.</b>
A gene is a substring of a genome that starts with
the start codon (ATG), end with a stop codon (TAG, TAA, TAG, or TGA)
and consists of a sequence of codons (nucleotide triplets)
other than the start or stop codons. The gene is the
substring in between the start and stop codons.

<li><b>Repeat finder.</b>
Write a program <tt>Repeat.java</tt> that takes two command line arguments,
and finds the maximum number of repeats of the first command line argument
in the file specified by the second command line argument.

<li><b>Character filter.</b>
Given a string <tt>t</tt> of
<em>bad characters</em>, e.g. <tt>t = "!@#$%^&*()-_=+"</tt>,
write a function to read in another string <tt>s</tt> and
return the result of removing all of the bad characters.
<p>
<blockquote>
<table>
<TR><TD><pre>
String pattern = "[" + t + "]";
String result  = s.replaceAll(pattern, "");
</pre></td></tr>
</table>
</blockquote>


<li><b>Wildcard pattern matcher.</b>
Without using Java's built in regular expressions,
write a program <a href = "Wildcard.java.html">Wildcard.java</a>
to find all words in the dictionary matching a given
pattern. The special symbol * matches any zero or more characters.
So, for example the pattern "w*ard" matches the word "ward" and
"wildcard". The special symbol . matches any one character.
Your program should read the pattern as a command line parameter
and the list of words (separated by whitespace) from standard input.

<li><b>Wildcard pattern matcher.</b>
Repeat the previous exercise, but this time use Java's
built in regular expressions. <em>Warning:</em> in the context
of wildcards, * has a different meaning than with regular expressions.

<li><b>Search and replace.</b>
Word processors allow you to search for all occurrences of
a given query string and replace each with another replacement string.
Write a program
<a href = "SearchAndReplace.java.html">SearchAndReplace.java</a> that
takes two strings as command line inputs,
reads in data from standard input, and replaces all occurrences of
the first string with the second string, and
sends the results to standard output.
<em>Hint</em>: use the method <tt>String.replaceAll</tt>.

<li><b>Password validator.</b>
Suppose that for security reasons you require all passwords
to have at least one of the following characters
<blockquote>
<table>
<TR><TD><pre>
~ ! @ # $ % ^ & * | 
</pre></td></tr>
</table>
</blockquote>

Write a regular expression for use with <tt>String.matches</tt>
that returns <tt>true</tt> if and only if the password contains one of the
required characters.
<em>Answer</em>: "^[^~!@#$%^&*|]+$" 

<li><b>Alphanumeric filter.</b>
Write a program <a href = "Filter.java.html">Filter.java</a>
to read in text from standard input and eliminate all
characters that are not  whitespace or alpha-numeric.
<em>Answer</em> here's the key line.
<blockquote>
<table>
<TR><TD><pre>
String output = input.replaceAll("[^\\s0-9a-zA-Z]", "");
</pre></td></tr>
</table>
</blockquote>


<li><b>Converting tabs to spaces.</b>
Write a program to convert all tabs in a Java source file to 4 spaces.



<li><b>Parsing delimited text files.</b>
A popular way to store a database is in a text file with one record per line,
and each field separated by a special character called the delimiter.
<blockquote>
<table>
<TR><TD><pre>
19072/Narberth/PA/Pennsylvania
08540/Princeton/NJ/New Jersey
</pre></td></tr>
</table>
</blockquote>

Write a program <a href = "Tokenizer.java.html">Tokenizer.java</a> 
that reads in two command line parameters, a delimiter character and
the name of the file, and creates an array of tokens.

<li><b>Parsing delimited text files.</b>
Repeat the previous exercise, but use the <tt>String</tt> library
method <tt>split()</tt>.

<li><b>PROSITE to Java regular expression.</b>
Write a program to read in a PROSITE pattern and print out
the corresponding Java regular expression.

<li><b>Checking a file format.</b>

<li><b>Misspellings.</b>
Write a Java program to verify that this list of
<a href = "misspellings.txt">common misspellings</a>
adapted from <a href = "http://en.wikipedia.org/wiki/Wikipedia:List_of_common_misspellings">Wikipedia</a>
contains only lines of the form
<blockquote>
<table>
<TR><TD><pre>
misdemenors (misdemeanors)
mispelling (misspelling)
tennisplayer (tennis player)
</pre></td></tr>
</table>
</blockquote>
<p>
where the first word is the misspelling and the string in parentheses is
a possible replacement.

<li>
<a href = "http://rec-puzzles.org/new/sol.pl/language/english/spelling/single.words">interesting 
English words</a> </ol>


</ul>


<br><br>
<p class = footer>
<em>Last modified on October 23, 2012.</em><br><br>
Copyright &copy; 2002&ndash;2012
<a href = "http://www.cs.princeton.edu/~rs" class = footer>Robert Sedgewick</a>
and
<a href = "http://www.cs.princeton.edu/~wayne" class = footer>Kevin Wayne</a>.
All rights reserved.
</div>




<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-10811519-1");
pageTracker._trackPageview();
} catch(err) {}</script>


</body>

</html>






 

